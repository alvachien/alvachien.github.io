<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>[.NET] WPF中Resource调用方法小析 | Alva Chien’s Blog</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="[.NET] WPF中Resource调用方法小析" />
<meta name="author" content="alvachien" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="WPF支持两种格式的Resource，即binary resource和logical resource。而Binary resource又有三种方法：可以嵌入在assembly中，编译时才打包的独立文件，运行时的独立文件。至于binary resource的culture属性不在这里讨论。Visual Studio为WPF Project中的Resource定义了Action： Resource: 将指定文件嵌入Assembly。 Content：指定文件不会嵌入Assembly，但编译时会打包。通常该选项用在HTML文件直接读取的场合。 EmbeddedResource：该选项不应该被使用！ WPF为了能够调用Resource，提供了一套uniform resource identifier (URI)机制。该机制不仅能在Code中直接访问Resource，更可以在XAML中直接调用。然而，这套机制的出台，也为Resource的调用增加了麻烦。" />
<meta property="og:description" content="WPF支持两种格式的Resource，即binary resource和logical resource。而Binary resource又有三种方法：可以嵌入在assembly中，编译时才打包的独立文件，运行时的独立文件。至于binary resource的culture属性不在这里讨论。Visual Studio为WPF Project中的Resource定义了Action： Resource: 将指定文件嵌入Assembly。 Content：指定文件不会嵌入Assembly，但编译时会打包。通常该选项用在HTML文件直接读取的场合。 EmbeddedResource：该选项不应该被使用！ WPF为了能够调用Resource，提供了一套uniform resource identifier (URI)机制。该机制不仅能在Code中直接访问Resource，更可以在XAML中直接调用。然而，这套机制的出台，也为Resource的调用增加了麻烦。" />
<link rel="canonical" href="http://localhost:4000/net-wpf-e4-b8-adresource-e8-b0-83-e7-94-a8-e6-96-b9-e6-b3-95-e5-b0-8f-e6-9e-90" />
<meta property="og:url" content="http://localhost:4000/net-wpf-e4-b8-adresource-e8-b0-83-e7-94-a8-e6-96-b9-e6-b3-95-e5-b0-8f-e6-9e-90" />
<meta property="og:site_name" content="Alva Chien’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2010-12-21T23:11:00+08:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","headline":"[.NET] WPF中Resource调用方法小析","url":"http://localhost:4000/net-wpf-e4-b8-adresource-e8-b0-83-e7-94-a8-e6-96-b9-e6-b3-95-e5-b0-8f-e6-9e-90","dateModified":"2010-12-21T23:11:00+08:00","datePublished":"2010-12-21T23:11:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/net-wpf-e4-b8-adresource-e8-b0-83-e7-94-a8-e6-96-b9-e6-b3-95-e5-b0-8f-e6-9e-90"},"author":{"@type":"Person","name":"alvachien"},"description":"WPF支持两种格式的Resource，即binary resource和logical resource。而Binary resource又有三种方法：可以嵌入在assembly中，编译时才打包的独立文件，运行时的独立文件。至于binary resource的culture属性不在这里讨论。Visual Studio为WPF Project中的Resource定义了Action： Resource: 将指定文件嵌入Assembly。 Content：指定文件不会嵌入Assembly，但编译时会打包。通常该选项用在HTML文件直接读取的场合。 EmbeddedResource：该选项不应该被使用！ WPF为了能够调用Resource，提供了一套uniform resource identifier (URI)机制。该机制不仅能在Code中直接访问Resource，更可以在XAML中直接调用。然而，这套机制的出台，也为Resource的调用增加了麻烦。","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=38b3be967079cbe7b6039207c9aed65383e94bce">
    <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1><a href="http://localhost:4000/">Alva Chien's Blog</a></h1>
        
        

        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p>

        
        <p class="view"><a href="https://github.com/alvachien/alvachien.github.io">View the Project on GitHub <small>alvachien/alvachien.github.io</small></a></p>
        

        

        
      </header>
      <section>

      <small>21 December 2010</small>
<h1>[.NET] WPF中Resource调用方法小析</h1>

<p class="view">by alvachien</p>

<p>WPF支持两种格式的Resource，即binary resource和logical resource。而Binary resource又有三种方法：可以嵌入在assembly中，编译时才打包的独立文件，运行时的独立文件。至于binary resource的culture属性不在这里讨论。Visual Studio为WPF Project中的Resource定义了Action：</p>
<ul>
	<li>Resource: 将指定文件嵌入Assembly。</li>
	<li>Content：指定文件不会嵌入Assembly，但编译时会打包。通常该选项用在HTML文件直接读取的场合。</li>
	<li>EmbeddedResource：该选项不应该被使用！</li>
</ul>
<p>WPF为了能够调用Resource，提供了一套<span style="text-decoration: underline;">uniform resource identifier (URI)</span>机制。该机制不仅能在Code中直接访问Resource，更可以在XAML中直接调用。然而，这套机制的出台，也为Resource的调用增加了麻烦。</p>

<p>为了说明问题，首先定义一个具体的Scenario。该Scenario如下：App1.exe，调用Mod1.dll。通常App1.exe只是个入口程序，无实际代码，但需要其打包程序所对应的Icon。Mod1.dll则负责具体Window和各种Popup的逻辑。由此可见，有如下两种Resource的调用需求：</p>
<ol>
	<li>App1.exe需要封装Icon。该Icon是整个程序级别的。</li>
	<li>Mod1.dll中的Resource。简单起见，还是用Icon为例。</li>
</ol>
<p>对于需求1，需要在Resources.resx中将对应的Icon加为资源。为了使该Icon应用在整个程序，需要在Project的Setting中的Application Tab设置Icon信息。如下图所示：</p>

<p><a href="http://www.alvachien.com/alvablog/wp-content/uploads/2010/12/Capture1.jpg"><img class="alignnone size-full wp-image-1015" title="Project setting" src="http://www.alvachien.com/alvablog/wp-content/uploads/2010/12/Capture1.jpg" alt="" width="569" height="160" /></a></p>

<p><a href="../wp-content/uploads/2010/12/Capture1.jpg"></a></p>

<p>对于需求2，为了配套于MVVM模式，也为了提高Performance，通常在Memory中将对应的Icon缓存起来。根据Resource时候被加入Project，其调用方法也不同。</p>
<ul>
	<li>嵌入在Assembly的Resource。在XAML中调用的示例代码：
&lt;Button.Content&gt;
<span style="color: #ff0000;">&lt;Image Source="/Mod1;component/Resources/cancel.png" /&gt;
</span>&lt;/Button.Content&gt;
这里，Mod1为该DLL的Assembly Name。'/Resources/cancel.png'是其具体路径。
在Code中，其语法为。
myImage = new System.Windows.Controls.Image();
myImage.Width = 32;
myBitmapImage = new System.Windows.Media.Imaging.BitmapImage();
myBitmapImage.BeginInit();
<span style="color: #ff0000;">myBitmapImage.UriSource = new Uri("pack://application:,,,/Mod1;component/Resources/cancel.png", UriKind.Absolute);
</span>myBitmapImage.DecodePixelWidth = 32;
myBitmapImage.EndInit();
myImage.Source = myBitmapImage;</li>
	<li>独立文件。为了方便用户可以自由切换图片，使用独立文件也不失为一种上佳选择，当然，其风险也是不言而喻的，独立文件无法被正常打开时，会导致程序Crash。这里，我们假设应用程序会在运行目录的"Images\Icons"中查找对应的文件。同样，XAML的示例代码：
&lt;Button.Content&gt;
<span style="color: #ff0000;">&lt;Image Source="pack://siteoforigin:,,,/Images/Icons/Cancel.png" /&gt;
</span>&lt;/Button.Content&gt;
在Code中，其语法为：
myImage = new System.Windows.Controls.Image();
myImage.Width = 32;
myBitmapImage = new System.Windows.Media.Imaging.BitmapImage();
myBitmapImage.BeginInit();
<span style="color: #ff0000;">myBitmapImage.UriSource = new Uri("pack://siteoforigin:,,,/Images/Icons/Cancel.png", UriKind.Absolute);
</span>myBitmapImage.DecodePixelWidth = 32;
myBitmapImage.EndInit();
myImage.Source = myBitmapImage;</li>
</ul>
<p>对于MVVM模式，只需要将Button的Content与对应的Image进行Binding。</p>

<p>是为之记。
Alva Chien
2010.12.21</p>



  <small>tags: <em></em></small>



      </section>
      <footer>
        
        <p>This project is maintained by <a href="https://github.com/alvachien">alvachien</a></p>
        
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="/assets/js/scale.fix.js"></script>
    
  </body>
</html>
